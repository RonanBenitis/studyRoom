# <span style="color: #87BBA2">===   DevOps: explorando conceitos, comandos e scripts no Linux CLI   ===</span> <!-- omit in toc -->

# <span style="color: #87BBA2">INDICE</span> <!-- omit in toc -->
- [LINUX E DEVOPS](#linux-e-devops)
  - [MUNDO DEVOPS](#mundo-devops)
    - [Abordagem DevOps](#abordagem-devops)
    - [Virtual Machine](#virtual-machine)
    - [VirtualBox da Oracle](#virtualbox-da-oracle)
    - [Passo a passo](#passo-a-passo)
    - [Baixando Ubuntu](#baixando-ubuntu)
  - [CONFIGURANDO UM AMBIENTE LINUX](#configurando-um-ambiente-linux)
    - [Passo a passo](#passo-a-passo-1)
      - [Avan√ßando: Op√ß√µes de Mem√≥ria](#avan√ßando-op√ß√µes-de-mem√≥ria)
      - [Avan√ßando: Disco R√≠gido Virtual](#avan√ßando-disco-r√≠gido-virtual)
      - [IMPORTANTE: Sobre as Specs](#importante-sobre-as-specs)
      - [Avan√ßando: Sintese](#avan√ßando-sintese)
      - [Avan√ßando: Iniciando VM](#avan√ßando-iniciando-vm)
    - [√â comum n√≥s estarmos pr√≥ximos do servidor quando colocamos um software em produ√ß√£o?](#√©-comum-n√≥s-estarmos-pr√≥ximos-do-servidor-quando-colocamos-um-software-em-produ√ß√£o)
  - [WSL COMO ALTERNATIVA AO USO DO VIRTUALBOX](#wsl-como-alternativa-ao-uso-do-virtualbox)
    - [O que √© WSL?](#o-que-√©-wsl)
  - [ACESSO VIA SSH](#acesso-via-ssh)
    - [Porque Linux?](#porque-linux)
    - [O que √© Sistema Operacional?](#o-que-√©-sistema-operacional)
    - [Acesso remoto, CONFORME ALURA](#acesso-remoto-conforme-alura)
    - [Passo a passo](#passo-a-passo-2)
    - [Acessando VM](#acessando-vm)
    - [Acesso Remoto com Port Forwarding e Conex√£o NAT (n√£o bridge)](#acesso-remoto-com-port-forwarding-e-conex√£o-nat-n√£o-bridge)
    - [**üìå Melhor n√£o usar modo Bridge?**](#-melhor-n√£o-usar-modo-bridge)
    - [**üìå Como conectar via SSH usando NAT (mais seguro)**](#-como-conectar-via-ssh-usando-nat-mais-seguro)
    - [**1Ô∏è‚É£ Configure o Port Forwarding no VirtualBox**](#1Ô∏è‚É£-configure-o-port-forwarding-no-virtualbox)
    - [**2Ô∏è‚É£ Descubra o IP da VM**](#2Ô∏è‚É£-descubra-o-ip-da-vm)
    - [**3Ô∏è‚É£ Conectar via SSH do Windows (CMD ou PowerShell)**](#3Ô∏è‚É£-conectar-via-ssh-do-windows-cmd-ou-powershell)
    - [**4Ô∏è‚É£ Insira a senha da VM**](#4Ô∏è‚É£-insira-a-senha-da-vm)
    - [**üìå Conclus√£o: NAT + Port Forwarding √© mais seguro!**](#-conclus√£o-nat--port-forwarding-√©-mais-seguro)
  - [MAIS SOBRE NAT E BRIDGE](#mais-sobre-nat-e-bridge)
    - [**üìå O que √© NAT e Bridge no VirtualBox?**](#-o-que-√©-nat-e-bridge-no-virtualbox)
    - [**1Ô∏è‚É£ NAT (Network Address Translation) - Modo padr√£o do VirtualBox**](#1Ô∏è‚É£-nat-network-address-translation---modo-padr√£o-do-virtualbox)
    - [**2Ô∏è‚É£ Bridge (Placa em modo Bridge - Ponte)**](#2Ô∏è‚É£-bridge-placa-em-modo-bridge---ponte)
    - [**üìå Por que a VM consegue acessar a internet no modo NAT?**](#-por-que-a-vm-consegue-acessar-a-internet-no-modo-nat)
    - [**üìå Qual escolher?**](#-qual-escolher)
    - [**üìå Conclus√£o**](#-conclus√£o)
    - [**üìå Como o NAT funciona para conex√£o na internet?**](#-como-o-nat-funciona-para-conex√£o-na-internet)
    - [**üõ† Como o NAT funciona no VirtualBox?**](#-como-o-nat-funciona-no-virtualbox)
    - [**üìå "Mas o NAT n√£o abre brecha de seguran√ßa como o Bridge?"**](#-mas-o-nat-n√£o-abre-brecha-de-seguran√ßa-como-o-bridge)
    - [**üîí N√ÉO! Ele √© seguro porque:**](#-n√£o-ele-√©-seguro-porque)
    - [**üìå Como funciona o NAT no meu PC quando estou no Wi-Fi de casa?**](#-como-funciona-o-nat-no-meu-pc-quando-estou-no-wi-fi-de-casa)
    - [**üìå Conclus√£o**](#-conclus√£o-1)
  - [COMANDOS PARA PRATICAR](#comandos-para-praticar)
- [EXPLORANDO O LINUX SERVER](#explorando-o-linux-server)
  - [NAVEGANDO NO LINUX SERVER](#navegando-no-linux-server)
    - [**Escalando privil√©gios com `sudo`**](#escalando-privil√©gios-com-sudo)
    - [**Verificando pacotes e atualiza√ß√µes**](#verificando-pacotes-e-atualiza√ß√µes)
    - [**üìå Significado de algumas siglas importantes**](#-significado-de-algumas-siglas-importantes)
    - [**üìå O que √© Shell CLI?**](#-o-que-√©-shell-cli)
    - [**üìå Por que o nome "Shell"?**](#-por-que-o-nome-shell)
    - [**üìå Tipos de Shell**](#-tipos-de-shell)
    - [**üìå Shell no contexto do VirtualBox e Ubuntu**](#-shell-no-contexto-do-virtualbox-e-ubuntu)
    - [**üìå Estrutura Geral de um Comando no Linux**](#-estrutura-geral-de-um-comando-no-linux)
    - [**üìå Exemplo 1: Comando `ls`**](#-exemplo-1-comando-ls)
    - [**üìå Exemplo 2: Comando `sudo apt install`**](#-exemplo-2-comando-sudo-apt-install)
    - [**üìå Tipos de Elementos em um Comando**](#-tipos-de-elementos-em-um-comando)
    - [**üìå Teste na Pr√°tica**](#-teste-na-pr√°tica)
    - [Criando um diret√≥rio (pasta) e indo at√© ele](#criando-um-diret√≥rio-pasta-e-indo-at√©-ele)
  - [GERENCIANDO ARQUIVOS](#gerenciando-arquivos)
    - [Criando arquivo (touch)](#criando-arquivo-touch)
    - [Inserindo notas e conferindo (cat)](#inserindo-notas-e-conferindo-cat)
    - [Alternativas de inser√ß√£o de conte√∫do com echo](#alternativas-de-inser√ß√£o-de-conte√∫do-com-echo)
    - [Outra alternativa comum para edi√ß√£o de texto (nano)](#outra-alternativa-comum-para-edi√ß√£o-de-texto-nano)
    - [Movendo arquivos (mv)](#movendo-arquivos-mv)
    - [Removendo arquivos (rm)](#removendo-arquivos-rm)
  - [REMOVENDO ARQUIVOS E DIRET√ìRIOS](#removendo-arquivos-e-diret√≥rios)
  - [IMPORTANTE DICA](#importante-dica)
  - [PARAMETROS DE LISTAGEM](#parametros-de-listagem)
  - [Praticando](#praticando)
    - [Outra atividade](#outra-atividade)
- [SHELL SCRIPTING](#shell-scripting)
  - [CONSTRUINDO SCRIPTS NO SHELL](#construindo-scripts-no-shell)
    - [Caso pr√°tico](#caso-pr√°tico)
    - [Criando Shell Script](#criando-shell-script)
  - [PARA SABER MAIS: TESTANDO DIFERENTES CONDI√á√ïES](#para-saber-mais-testando-diferentes-condi√ß√µes)
    - [Igualdade entre duas strings](#igualdade-entre-duas-strings)
    - [Desigualdade entre duas strings](#desigualdade-entre-duas-strings)
    - [Igualdade entre dois n√∫meros](#igualdade-entre-dois-n√∫meros)
    - [Desigualdade entre dois n√∫meros](#desigualdade-entre-dois-n√∫meros)
    - [Testando se um n√∫mero √© maior que outro](#testando-se-um-n√∫mero-√©-maior-que-outro)
    - [Testando se um n√∫mero √© menor que outro](#testando-se-um-n√∫mero-√©-menor-que-outro)
    - [Testando se um n√∫mero √© maior ou igual a outro](#testando-se-um-n√∫mero-√©-maior-ou-igual-a-outro)
    - [Verificando a exist√™ncia de um arquivo ou diret√≥rio](#verificando-a-exist√™ncia-de-um-arquivo-ou-diret√≥rio)
  - [PASSAGEM DE PARAMETROS](#passagem-de-parametros)
    - [Scripts com parametros](#scripts-com-parametros)
      - [Validando se parametros foram passados](#validando-se-parametros-foram-passados)
      - [Pegando os parametros](#pegando-os-parametros)
      - [Compactando](#compactando)
      - [Script completo](#script-completo)
      - [Executando script](#executando-script)
  - [PARA SABER MAIS: PASSANDO PARAMETROS EM SCRIPTS](#para-saber-mais-passando-parametros-em-scripts)
  - [**üìå Diferen√ßa entre `$VARIAVEL` e `${VARIAVEL}`**](#-diferen√ßa-entre-variavel-e-variavel)
    - [**üéØ Exemplo pr√°tico: Quando `${}` √© necess√°rio**](#-exemplo-pr√°tico-quando--√©-necess√°rio)
    - [**üìå Seguran√ßa e legibilidade**](#-seguran√ßa-e-legibilidade)
    - [**üî• Resumo final**](#-resumo-final)
  - [EXEMPLOS DE SCRIPT](#exemplos-de-script)
    - [Verificando existencia de arquivos na pasta](#verificando-existencia-de-arquivos-na-pasta)
    - [Verifique a validade do caminho informado](#verifique-a-validade-do-caminho-informado)
    - [Exiba uma mensagem de boas-vindas quando executado](#exiba-uma-mensagem-de-boas-vindas-quando-executado)
    - [Criar uma c√≥pia de seguran√ßa de um diret√≥rio espec√≠fico](#criar-uma-c√≥pia-de-seguran√ßa-de-um-diret√≥rio-espec√≠fico)
    - [Solicite ao usu√°rio o nome de um diret√≥rio e, em seguida, o crie](#solicite-ao-usu√°rio-o-nome-de-um-diret√≥rio-e-em-seguida-o-crie)
    - [Aceite um nome de arquivo como argumento e verifique se o arquivo existe](#aceite-um-nome-de-arquivo-como-argumento-e-verifique-se-o-arquivo-existe)
    - [Utilize um loop para contar de 1 a 5](#utilize-um-loop-para-contar-de-1-a-5)
- [AUTOMATIZA√á√ÉO DE TAREFAS](#automatiza√ß√£o-de-tarefas)
  - [EXECUTANDO MULTIPLAS TAREFAS](#executando-multiplas-tarefas)
    - [Notas](#notas)
      - [Sintaxe case](#sintaxe-case)
      - [Descompactando](#descompactando)
  - [SHELL SCRIPTING COM APENAS OS DOCUMENTOS](#shell-scripting-com-apenas-os-documentos)
    - [Compactando apenas arquivos](#compactando-apenas-arquivos)
    - [Compactando caminho, descompactando apenas os arquivos](#compactando-caminho-descompactando-apenas-os-arquivos)
  - [FUN√á√ïES DIRETAS NO CLI](#fun√ß√µes-diretas-no-cli)
    - [**üî• Criando uma fun√ß√£o direto no CLI**](#-criando-uma-fun√ß√£o-direto-no-cli)
    - [**üìå Passando par√¢metros para a fun√ß√£o**](#-passando-par√¢metros-para-a-fun√ß√£o)
    - [**üìå Fun√ß√µes mais complexas**](#-fun√ß√µes-mais-complexas)
    - [**üìå Mas e se eu fechar o terminal?**](#-mas-e-se-eu-fechar-o-terminal)
    - [**üöÄ Resumo**](#-resumo)
  - [QUANDO USAR E QUANDO N√ÉO USAR ASPAS](#quando-usar-e-quando-n√£o-usar-aspas)
    - [**1Ô∏è‚É£ Por que `"$arquivo_saida"` e `"$caminho"` t√™m aspas?**](#1Ô∏è‚É£-por-que-arquivo_saida-e-caminho-t√™m-aspas)
    - [**2Ô∏è‚É£ Por que `$arquivos` est√° sem aspas?**](#2Ô∏è‚É£-por-que-arquivos-est√°-sem-aspas)
    - [**üìå Regra Geral**](#-regra-geral)
    - [**Resumo**](#resumo)
  - [INSTALANDO UM SERVIDOR WEB](#instalando-um-servidor-web)
    - [O que √© um servidor web](#o-que-√©-um-servidor-web)
    - [Insalando Nginx em nosso servidor](#insalando-nginx-em-nosso-servidor)
      - [Verificando servidor web](#verificando-servidor-web)
  - [CONVERS√ÉO DE ARQUIVOS](#convers√£o-de-arquivos)
    - [Script](#script)
  - [EXEMPLO DE SCRIPTS](#exemplo-de-scripts)
    - [automatiza a atualiza√ß√£o de pacotes do sistema operacional.](#automatiza-a-atualiza√ß√£o-de-pacotes-do-sistema-operacional)
    - [renomeie todos os arquivos em um diret√≥rio, adicionando um prefixo ou sufixo especificado](#renomeie-todos-os-arquivos-em-um-diret√≥rio-adicionando-um-prefixo-ou-sufixo-especificado)
    - [automatiza a cria√ß√£o de usu√°rios no sistema, solicitando ao usu√°rio que forne√ßa o nome e outros detalhes necess√°rios](#automatiza-a-cria√ß√£o-de-usu√°rios-no-sistema-solicitando-ao-usu√°rio-que-forne√ßa-o-nome-e-outros-detalhes-necess√°rios)
    - [monitorar o espa√ßo em disco usando o comando df na coleta de informa√ß√µes](#monitorar-o-espa√ßo-em-disco-usando-o-comando-df-na-coleta-de-informa√ß√µes)
    - [**üìå O que acontece em `espaco`?**](#-o-que-acontece-em-espaco)
      - [**1Ô∏è‚É£ `df -h` ‚Üí Verifica o espa√ßo em disco**](#1Ô∏è‚É£-df--h--verifica-o-espa√ßo-em-disco)
      - [**2Ô∏è‚É£ `awk 'NR==2 {print $5}'` ‚Üí Filtra a linha e coluna certas**](#2Ô∏è‚É£-awk-nr2-print-5--filtra-a-linha-e-coluna-certas)
      - [**3Ô∏è‚É£ `sed 's/%//'` ‚Üí Remove o s√≠mbolo `%`**](#3Ô∏è‚É£-sed-s--remove-o-s√≠mbolo-)
    - [**üìå Recapitulando o que acontece**](#-recapitulando-o-que-acontece)
    - [**üìå Exemplo pr√°tico**](#-exemplo-pr√°tico)
    - [automatizar o backup de um diret√≥rio espec√≠fico para um local de destino, utilizando a compress√£o gzip](#automatizar-o-backup-de-um-diret√≥rio-espec√≠fico-para-um-local-de-destino-utilizando-a-compress√£o-gzip)

# <span style="color: #87BBA2">LINUX E DEVOPS</span>

## MUNDO DEVOPS
Contextualizado em um mundo onde o ambiente de desenvolvimento de software √© departamentalizado, separado, e a colabora√ß√£o e integra√ß√£o torna-se um fator de alta importancia.

Assim que uma aplica√ß√£o estiver pronta, testada e aprovada, ela precisar√° ser colocada de forma dispon√≠vel aos usu√°rios, seu publico alvo. O que ir√° cuidar do local onde nossa aplica√ß√£o estar√° disponivel aos usu√°rio, ser√° a infraestrutura.

O time de pessoas dedicadas a manuten√ß√£o e monitoramento desta parte do sistema √© o time de opera√ß√µes. Ou seja, √© o time que lida com as tarefas da implementa√ß√£o e manuten√ß√£o de um sistema em produ√ß√£o.

- Devs: Responsaveis pela constru√ß√£o da aplica√ß√£o;
- DevOps: Integra desenvolvimento e opera√ß√µes;
  - Ou seja, disponibilizar e manter de forma eficiente aos seu usu√°rios.

### Abordagem DevOps
Cultura que surge para integrar essas duas equipes e torna-las respons√°veis pela cria√ß√£o, manuten√ß√£o, desempenho, seguran√ßa e eficiente √† aplica√ß√£o que est√° sendo disponibilizada aos usu√°rios.

**A√≠ que nasce o DevOps, que √© a uni√£o do termo "Developer" com "Operations".**

### Virtual Machine
Maquina virtual, ou VM, pode ser descrita como:
- uma duplicata eficiente e isolada de uma maquina real;
- c√≥pia isolada de um sistema f√≠sico, sendo totalmente protegida
  - segundo Alura: um software que emula o funcionamento de um sistema operacional sobre um outro sistema operaciona no mesmo dispositivo, tendo, sob um √∫nico hardware diferentes sistemas operacionais em funcionamento.

### VirtualBox da Oracle
Para utilizar uma Virtual Machine, utilizaremos o Virtual Box da Oracle, onde podemos baix√°-lo neste [link.](https://www.virtualbox.org/wiki/Downloads)
> Ideal baixarmos sempre a ultima vers√£o.

Para instru√ß√µes de como baix√°-lo, [veja aqui a partir dos minutos 4:13](https://cursos.alura.com.br/course/devops-conceitos-comandos-scripts-linux-cli/task/146504)

### Passo a passo
1. Abrimos o Virtual Box
2. Clicamos em **Novo**
   1. Uma janela ser√° aberta
3. Damos o nome "Linux" √† VM
   1. Note que a segunda op√ß√£o √© **a pasta**, ou seja, √© o local onde ser√£o armazenados todos os arquivos relacionados a esta VM
4. Na imagem ISO, precisaremos subir a imagem do sistema operacional que utilizaremos nessa VM
   1. No nosso caso, √© o Ubuntu, precisaremos baixar essa imagem

### Baixando Ubuntu
O site para realizar o download da ISO do Ubuntu √© [este site](https://ubuntu.com/download);
- L√°, existem varias op√ß√µes de imagem. N√≥s queremos a imagem para Servidores, que √© o que normalmente colocamos no ambiente de produ√ß√£o.
- **Importante**: Na aba de "Manual server installation", queremos baixar a vers√£o mais recenete **que possua o termo LTS** ao seu lado, ou seja, Long Term Support, pois, como nosso servidor funcionar√° por um longo per√≠odo de tempo, queremos que ele seja o mais est√°vel poss√≠vel.

## CONFIGURANDO UM AMBIENTE LINUX

### Passo a passo
1. Retornamos a aba de "Novo" e na imagem ISO colocamos o arquivo .iso que baixamos
2. Na caixa "Pular Instala√ß√£o Desassistida" √© important√≠ssimo seleciona-la
   1. Nesta etapa, gostariamos de realizar a configura√ß√£o manualmente para vermos na pr√°tica como funcionar√°

#### Avan√ßando: Op√ß√µes de Mem√≥ria
1. Na proxima tela, teremos as op√ß√µes de mem√≥ria
   1. Importante **N√ÉO** alocarmos toda a mem√≥ria de nosso PC e nem todos os nossos processadores, recomendando, para este cen√°rio, n√£o passar de 1/3 da mem√≥ria e 2 processadores.
   2. No nosso caso, n√£o necessitaremos de mais do que 2048MB de mem√≥ria. Ent√£o, deixaremos como 4096MB
   3. Para os processadores, pegaremos dois.

#### Avan√ßando: Disco R√≠gido Virtual
1. Aqui, no Disco R√≠gido Virtual, deixaremos como a op√ß√£o **default**, pois, n√£o precisaremos mais do que 25 GB

#### IMPORTANTE: Sobre as Specs
Na pr√°tica, quando n√≥s formos configurar um servidor para hospedaremos a solu√ß√£o que estamos constru√≠ndo, precisaremos analisar com maior cuidado esses detalhes e especifica√ß√µes, de acordo com o sistema que deixaremos em execu√ß√£o.

#### Avan√ßando: Sintese
1. Aparecer√° uma sintese do que escolhemos e, ent√£o, clicamos em finalizar.

#### Avan√ßando: Iniciando VM
1. No menu superior, clique em iniciar
2. Selecionamos a op√ß√£o "Try or install Ubuntu Server".
3. Escolha a lingua desejada
4. Na variante do teclado, vemos que j√° est√° em Portugu√™s, avan√ßamos
5. No "base for the installation", escolheremos, para esta aula, o **Ubuntu Server (minimized)**, sendo a op√ß√£o do meio.
   1. Clique espa√ßo para selecionar a op√ß√£o
   2. A barra de sele√ß√£o vai apra "Cocluido / Voltar" e clicamos "Enter" em Conclu√≠do para avan√ßar a tela
6. Proxima tela √© a configura√ß√£o de liga√ß√µes de rede
   1. Como iremos querer fazer o acesso remoto desta VM usando SSH, √© importante garantir que n√≥s estejamos vinculando esta VM com uma placa de rede f√≠sica.
   2. Precisamos s√≥ garantir que estamos vinculando a uma placa de rede f√≠sica e observarmos se j√° est√° configurado corretamente.
   3. Ent√£o, como j√° foi alocado e tem um DHCPv4, avan√ßaremos.
7. Para configura√ß√£o de Proxy, no momento, deixaremos default, clicamos em **Conclu√≠do**
8. Inicia-se a configura√ß√£o da imagem baixando pacotes de instala√ß√£o
   1. Durante a instala√ß√£o do Ubuntu, o sistema precisa baixar pacotes e atualiza√ß√µes. Para isso, ele utiliza um mirror (espelho), que √© basicamente um servidor de r√©plicas onde ficam armazenados os pacotes do sistema
9. Caso apare√ßa algumas mensagens de FAILED, n√£o tem problema. Damos um enter para avan√ßar
10. Caso recebermos o erro de "FAILED unmounting /cdrom", n√£o precisamos nos preocupar

**EXPLICA√á√ÇO DO CASO (GPT):**

Essas mensagens indicam que o sistema tentou desmontar (unmount) o /cdrom (o disco de instala√ß√£o do Ubuntu), mas falhou. Vamos entender melhor:

üìå O que significa "Failed unmounting /cdrom"?
Durante a instala√ß√£o do Ubuntu em uma VM, a ISO (imagem do sistema) √© montada como um CD virtual no diret√≥rio /cdrom. Quando a instala√ß√£o termina, o sistema tenta desmontar (unmount) essa m√≠dia antes de reiniciar.

Por√©m, essa desmontagem pode falhar por alguns motivos, como:

- A ISO ainda est√° em uso ‚Üí O sistema pode estar acessando arquivos da ISO no momento da desmontagem.
- Processo bloqueado ‚Üí Algum servi√ßo pode estar travado e impedindo a desmontagem.
- Erro normal do VirtualBox ‚Üí Em VMs, essa falha √© comum e geralmente n√£o causa problemas.

üìå O que fazer quando isso acontece?
No seu caso, a instala√ß√£o j√° foi conclu√≠da, ent√£o basta seguir a instru√ß√£o:

"Please remove the installation medium, then press ENTER."

Isso significa que voc√™ deve:

- Ejetar a ISO do VirtualBox
  - V√° at√© Dispositivos ‚Üí Unidade de CD/DVD ‚Üí Remover disco da unidade virtual.
- Pressionar ENTER na VM para continuar.
  
Caso n√£o remova a ISO, a VM pode tentar iniciar a instala√ß√£o do Ubuntu novamente ao inv√©s de carregar o sistema j√° instalado.

11. Instrutor apenas deu um ENTER e saiu da tela
12. Aparentemente, inicia-se a instala√ß√£o do Ubuntu e devemos aguardar sua conclus√£o.
13. Agora, coloque o login e senha configurados (Particularmente, n√£o sei onde foi configurado)
14. Ap√≥s isso, a nossa VM foi configurada com sucesso

### √â comum n√≥s estarmos pr√≥ximos do servidor quando colocamos um software em produ√ß√£o?
N√£o! N√£o √© comum! Na realidade, o mais comum √© nem sabermos a posi√ß√£o geografica deste servidor e, para acess√°-lo, realizar de forma remota atrav√©s da tecnologia SSH, o que veremos a seguir.

## WSL COMO ALTERNATIVA AO USO DO VIRTUALBOX
Alguns computadores podem apresentar certa lentid√£o e at√© mesmo alguns bugs quando usamos m√°quinas virtuais (VMs) atrav√©s de softwares de virtualiza√ß√£o como o VirtualBox.

Se este for o seu caso, temos uma alternativa de virtualiza√ß√£o de ambiente Linux no Windows que pode facilitar bastante sua trajet√≥ria de aprendizado aqui no curso: o uso do Windows Subsystem for Linux (WSL). O WSL √© um recurso do Windows 10 e Windows 11 que permite executar um ambiente Linux diretamente no Windows, sem a necessidade de uma VM. Com o WSL, voc√™ pode instalar distribui√ß√µes Linux (como Ubuntu, Debian, e outras) e utiliz√°-las como se fossem aplicativos nativos do Windows.

Todos os passos e configura√ß√µes que faremos aqui s√£o compat√≠veis com o WSL, sendo assim voc√™ n√£o ter√° nenhuma perda de aprendizado ao optar por esse ambiente.

Para come√ßar a usar o WSL, siga os passos abaixo:
1. Abra o PowerShell como administrador e execute o comando wsl --install.
2. Ap√≥s a instala√ß√£o inicial, voc√™ pode instalar outras distribui√ß√µes dispon√≠veis na Microsoft Store. Assim, basta escolher a distribui√ß√£o Ubuntu (a mesma que estamos usando no curso).
3. Para acessar o WSL, basta procurar pela distribui√ß√£o instalada no menu iniciar (pesquise, por exemplo, "Ubuntu"). Com alguns poucos passos, voc√™ ter√° um terminal Linux pronto para dar sequ√™ncia aqui no curso!

### O que √© WSL?
WSL significa Windows Subsystem for Linux (ou Subsistema Linux para Windows) e permite que desenvolvedores executem um ambiente GNU/Linux diretamente no Windows, sem precisar de uma m√°quina virtual ou realizar um dual-boot.

Essa ferramenta j√° est√° em funcionamento h√° alguns anos e atualmente conta com sua segunda vers√£o publicada, o WSL2.

O grande benef√≠cio de conhecer e utilizar essas ferramentas, incluindo o seu contexto de estudos aqui na Alura, √© que fica muito mais f√°cil de seguir os passos de colegas que j√° utilizam sistemas Linux como ambiente de desenvolvimento.

Outra vantagem √© que, ao compreender mais esses recursos, podemos nos adequar a grandes comunidades que usam o Linux com muito peso, como os usu√°rios da ferramenta Docker.

Temos um [artigo que voc√™ pode consultar caso tenha alguma d√∫vida em rela√ß√£o ao processo de configura√ß√£o e funcionamento do WSL](https://www.alura.com.br/artigos/wsl-executar-programas-comandos-linux-no-windows).

## ACESSO VIA SSH

### Porque Linux?
O Linux √© um projeto open source (c√≥digo aberto) de sistema operacional registrado sob a licen√ßa GPL, uma licen√ßa p√∫blica geral. Dessa forma, podemos utilizar esse projeto, criar outras vers√µes para dispositivos espec√≠ficos, seja um dispositivo IoT, servidor ou smartphone, gratuitamente e nos comprometemos em deixar esse projeto que criamos tamb√©m de forma aberta.

Mas, o Linux n√£o √© um sistema operacional, e sim um n√∫cel (Kernel) de sistema operacional, sendo a base principal que utilizamos para criar diferentes distribui√ß√µes, sendo as distribui√ß√µes as que chamamos de **distros**, como o Ubuntu, Fedora, Android etc.

Quase toda a infraestrutura da internet √© construida sobre o kernel do Linux.

### O que √© Sistema Operacional?
N√£o trata-se de uma caixinha, mas sim, m√≥dulos que s√£o integrados para oferecer uma s√©rie de funcionalidades ao usu√°rio final. O Kernel √© a parte principal, o n√∫cleo, mas de acordo com a aplica√ß√£o ou o dispositivo onde esse sistema ser√° instalado pode-se adicionar outros m√≥dulos, como drivers e etc.

### Acesso remoto, CONFORME ALURA
Utilizaremos o protocolo SSH, que permite a conex√£o com uma m√°quina de forma remota.

### Passo a passo
Precisaremos:
1. IP da VM

Mas antes, precisamos fazer:
**ATEN√á√ÉO, VEJA O M√âTODO PORT FORWARDING ABAIXO, √â MAIS SEGURO**
1. Na VM aberta (olhando no terminal), vamos no menu Dispositivos
   1. Rede
   2. Configura√ß√µes de rede
   3. Alterar o "Conectado a" de NAT para Placa em modo Bridge
   4. E o Name precisar√° mostrar uma placa f√≠sica, realmente
   5. Clique ok
2. Agora, digite o comando `ip address`
   1. Observamos a interface "loopback" que √© a interface que a m√°quina usa para falar com ela mesma
   2. Observamos a interface, tamb√©m, outra interface com um nome mais complicada (enp0s3), √© nessa interface que receberemos o endere√ßo de IP
   3. As vezes ela n√£o aparece de imediato, caso realizamos alguma altera√ß√£o recente (como a de passagem de NAT para Bridge), a√≠ precisamos esperar um pouco mesmo
3. Demos um tempo e digitamos o comando `ip_address` novamente, mas, sem sucesso de retorno
   1. Vamos no menu Dispositivo > rede
   2. Clicar em Conectar Placa de Rede
4. `ip_address` de novo, e na interface enp0s3 vimos que estabeleceu o IP: 192.168.40.36, no caso.

### Acessando VM
1. Vamos agora no prompt de comando (cmd windows)
2. digitamos `ssh username_que_definimos@endereco_da_maquina_que_desejamos_conectar`
   1. No exemplo do instrutor: `ssh lucasrm@192.168.40.36`
   2. Dado enter
3. Dando certo, solicitar√° a senha e inserimos a senha
4. Ap√≥s isso, teremos em nosso prompt algo como `username@username: $`
   1. Isso indica que estamos dentro de nossa VM e os comandos que inserimos rodar√° nela.
5. Agora, rodemos o comando `ls`, que √© o comando de listar no Linux, e veremos que nada ser√° retornado. Isso √© um sucesso, pois, quer dizer que o comando foi reconhecido e nada foi retornado pois de fato h√° nada no diretorio.

### Acesso Remoto com Port Forwarding e Conex√£o NAT (n√£o bridge)
### **üìå Melhor n√£o usar modo Bridge?**  
Sim, **para um ambiente de estudos e testes, o modo NAT √© mais seguro e suficiente para conex√µes SSH**. O modo Bridge pode **expor sua VM na rede local**, o que pode trazer riscos caso voc√™ esteja em uma rede compartilhada ou sem firewall adequado.  

Mas **n√£o se preocupe!** Voc√™ **ainda pode se conectar via SSH no NAT**, apenas precisa configurar o **Port Forwarding** (Redirecionamento de Portas).  

---

### **üìå Como conectar via SSH usando NAT (mais seguro)**  

### **1Ô∏è‚É£ Configure o Port Forwarding no VirtualBox**  
1Ô∏è‚É£ **Com a VM desligada**, v√° at√© o **VirtualBox** e selecione sua VM.  
2Ô∏è‚É£ Clique em **Configura√ß√µes ‚Üí Rede**.  
3Ô∏è‚É£ Certifique-se de que o **Adaptador 1 est√° no modo NAT**.  
4Ô∏è‚É£ Clique em **Avan√ßado ‚Üí Redirecionamento de Portas**.  
5Ô∏è‚É£ Adicione uma nova regra com os seguintes valores:  
   - **Nome**: SSH  
   - **Protocolo**: TCP  
   - **Porta do host**: `2222` *(pode ser outra, mas lembre-se dela)*  
   - **IP do convidado**: `10.0.2.15` *(IP padr√£o do NAT no VirtualBox)*  
   - **Porta do convidado**: `22` *(porta padr√£o do SSH no Linux)*  
6Ô∏è‚É£ **Clique em OK e inicie a VM**.  

---

### **2Ô∏è‚É£ Descubra o IP da VM**  
Dentro da VM, abra o terminal e rode:  

```bash
ip address
```
üìå No modo NAT, o IP padr√£o geralmente ser√° **`10.0.2.15`**.  

Se quiser confirmar, rode:  

```bash
hostname -I
```

---

### **3Ô∏è‚É£ Conectar via SSH do Windows (CMD ou PowerShell)**  
Agora, no seu **Prompt de Comando (CMD)** do Windows, use:  

```bash
ssh -p 2222 username@localhost
```
üìå **Substitua "username" pelo usu√°rio da sua VM** (exemplo: `ssh -p 2222 ronan@localhost`).  

---

### **4Ô∏è‚É£ Insira a senha da VM**  
Se tudo estiver certo, ele pedir√° sua senha. **Digite-a** e pronto! üöÄ Agora voc√™ est√° conectado √† VM **sem precisar do modo Bridge**.  

---

### **üìå Conclus√£o: NAT + Port Forwarding √© mais seguro!**  
‚úÖ **Modo NAT protege sua VM de acessos externos.**  
‚úÖ **Port Forwarding permite acessar via SSH sem expor a VM na rede.**  
‚úÖ **Mais seguro para estudo e testes.**  

Se precisar de mais alguma ajuda na configura√ß√£o, s√≥ chamar! üî•

√ìtima pergunta! Vamos esclarecer isso de forma simples e pr√°tica.  

---

## MAIS SOBRE NAT E BRIDGE

### **üìå O que √© NAT e Bridge no VirtualBox?**  

Essas s√£o **configura√ß√µes de rede** que definem **como sua VM se conecta √† rede e √† internet**.  

---

### **1Ô∏è‚É£ NAT (Network Address Translation) - Modo padr√£o do VirtualBox**  

üîπ **Como funciona?**  
- O VirtualBox **cria uma rede privada interna** para a VM.  
- Sua VM **n√£o est√° diretamente vis√≠vel** na rede local, apenas o seu **PC hospedeiro** (Windows).  
- Quando a VM quer acessar a internet, **o VirtualBox faz a tradu√ß√£o de endere√ßo** e envia o tr√°fego pela conex√£o do seu PC.  

üîπ **Resumo:**  
‚úÖ A VM **tem acesso √† internet** automaticamente.  
‚úÖ √â **segura**, pois **n√£o fica vis√≠vel na rede local**.  
‚ùå **Outros dispositivos da rede n√£o conseguem acessar a VM facilmente** (precisa de Port Forwarding para isso).  

üí° **Exemplo de uso:**  
‚úî Quando voc√™ **s√≥ precisa acessar a internet a partir da VM**.  
‚úî Quando quer **evitar exposi√ß√£o desnecess√°ria da VM na rede**.  

---

### **2Ô∏è‚É£ Bridge (Placa em modo Bridge - Ponte)**  

üîπ **Como funciona?**  
- A VM **se conecta diretamente √† rede local**, como se fosse um outro computador f√≠sico na mesma rede.  
- Ela recebe um **IP diretamente do roteador**, assim como seu PC hospedeiro.  

üîπ **Resumo:**  
‚úÖ A VM **fica vis√≠vel na rede local**, podendo ser acessada por outros dispositivos.  
‚úÖ A VM pode **se comunicar facilmente com outros computadores** na rede.  
‚ùå **Pode ser inseguro**, pois exp√µe a VM como se fosse um PC normal na rede.  

üí° **Exemplo de uso:**  
‚úî Se voc√™ quer rodar um **servidor que deve ser acessado por outros dispositivos na rede**.  
‚úî Se voc√™ precisa **simular um ambiente real de rede**.  

---

### **üìå Por que a VM consegue acessar a internet no modo NAT?**  
Mesmo estando isolada, a VM pode acessar a internet porque o **VirtualBox age como um "roteador virtual"**. Ele recebe as solicita√ß√µes da VM e as repassa para a internet, como se fosse um intermedi√°rio.  

√â o mesmo princ√≠pio que acontece com seu Wi-Fi em casa:  
1Ô∏è‚É£ Seu computador tem um IP privado, mas acessa a internet porque o **roteador traduz os endere√ßos**.  
2Ô∏è‚É£ No NAT do VirtualBox, a VM tem um IP privado, mas acessa a internet atrav√©s do seu PC hospedeiro.  

---

### **üìå Qual escolher?**  
‚úÖ **Para estudo e seguran√ßa** ‚Üí Use **NAT** (e adicione Port Forwarding se precisar de acesso externo).  
‚úÖ **Para testes de rede ou simula√ß√£o de servidores** ‚Üí Use **Bridge** (mas cuidado com a seguran√ßa).  

Se precisar acessar a VM externamente, mas quiser manter NAT, pode usar **Port Forwarding**, como expliquei antes.  

---

### **üìå Conclus√£o**  
‚úî **NAT** ‚Üí Seguro, f√°cil, j√° conecta √† internet, mas sem acesso direto da rede.  
‚úî **Bridge** ‚Üí Mais liberdade na rede local, mas exp√µe a VM.  
‚úî **Sua VM acessa a internet no NAT porque o VirtualBox faz a tradu√ß√£o de endere√ßos**.  

Se precisar de mais alguma explica√ß√£o, s√≥ chamar! üöÄüî•

√ìtima pergunta, parceiro! Vamos entender isso de forma clara e conectada ao mundo real.  

---

### **üìå Como o NAT funciona para conex√£o na internet?**  

O **NAT (Network Address Translation - Tradu√ß√£o de Endere√ßos de Rede)** √© um m√©todo que permite que sua VM **use a conex√£o de internet do PC Host sem estar diretamente exposta √† rede**.  

### **üõ† Como o NAT funciona no VirtualBox?**  
1Ô∏è‚É£ **Sua VM recebe um IP privado (exemplo: `10.0.2.15`)**.  
2Ô∏è‚É£ **Quando a VM quer acessar a internet**, ela envia a solicita√ß√£o para o VirtualBox.  
3Ô∏è‚É£ **O VirtualBox age como um "roteador" e troca o IP da VM pelo IP do Host**.  
4Ô∏è‚É£ O tr√°fego vai para a internet como se fosse o Host acessando.  
5Ô∏è‚É£ Quando a resposta chega, o VirtualBox traduz de volta para a VM.  

üîπ **Isso √© igual ao que acontece no seu Wi-Fi em casa!** (Explico isso j√° j√° üëá).  

üîπ **A VM nunca aparece diretamente na rede local**, apenas o **Host** faz essa media√ß√£o.  

---

### **üìå "Mas o NAT n√£o abre brecha de seguran√ßa como o Bridge?"**  

### **üîí N√ÉO! Ele √© seguro porque:**  
‚úÖ **A VM n√£o est√° vis√≠vel na rede local** (ela n√£o tem um IP p√∫blico na rede).  
‚úÖ **Outros dispositivos na rede n√£o podem acess√°-la diretamente**.  
‚úÖ **Somente o VirtualBox sabe que a VM existe e controla o tr√°fego**.  
‚úÖ Mesmo que sua VM tenha um servi√ßo rodando (exemplo: um servidor web), **ningu√©m da rede local consegue acess√°-la diretamente** sem configura√ß√µes extras (como Port Forwarding).  

üìå **J√° no modo Bridge, a VM recebe um IP da rede local e fica exposta, podendo ser acessada por qualquer m√°quina da rede.**  

---

### **üìå Como funciona o NAT no meu PC quando estou no Wi-Fi de casa?**  

üîπ Seu **roteador Wi-Fi em casa faz NAT o tempo todo** para que seus dispositivos (PC, celular, TV) possam acessar a internet.  

üí° **Exemplo pr√°tico:**  
1Ô∏è‚É£ Voc√™ conecta seu PC e seu celular ao Wi-Fi de casa.  
2Ô∏è‚É£ O roteador d√° a cada dispositivo um **IP privado** (exemplo: `192.168.1.100`, `192.168.1.101`).  
3Ô∏è‚É£ Quando voc√™ acessa um site (`google.com`), seu PC manda o pedido para o roteador.  
4Ô∏è‚É£ O roteador **troca o IP privado pelo IP p√∫blico da sua internet** e envia o pedido.  
5Ô∏è‚É£ O site responde para o IP p√∫blico, e o roteador traduz de volta para seu PC.  

üîπ **Por isso, todos os seus dispositivos compartilham o mesmo IP p√∫blico, mas cada um tem um IP privado dentro da rede interna.**  

üîπ **O NAT do VirtualBox funciona igual!** A diferen√ßa √© que, em vez de um roteador de Wi-Fi, √© o pr√≥prio VirtualBox que faz esse papel.  

---

### **üìå Conclus√£o**  
‚úî **NAT no VirtualBox** = Mesma ideia do seu roteador Wi-Fi.  
‚úî **Seguro**, pois a VM **n√£o fica vis√≠vel na rede local**.  
‚úî **A VM acessa a internet atrav√©s do Host, mas sem exposi√ß√£o direta**.  
‚úî **O Bridge exp√µe a VM diretamente na rede, podendo ser menos seguro**.  

Se precisar de mais explica√ß√µes, s√≥ chamar, parceiro! üöÄüî•

## COMANDOS PARA PRATICAR
- `ls`: **list** - Lista os arquivos e diret√≥rios existentes dentro de um diret√≥rio
- `ls -a`: **list -all** - para exibir nos resultados da listagem os arquivos e pastas ocultas existentes dentro do diret√≥rio.
- `pwd`: **print working directory** - retorna o caminho completo do diret√≥rio em que voc√™ se encontra.
- `cd /caminho/do/diretorio/desejado`: **Change directory** - Para percorrer diferentes diret√≥rios dentro do Linux, podemos usar o seguinte comando
- `ls -l`: **ls -long** - para obter uma listagem mais detalhada, incluindo permiss√µes, propriet√°rio, tamanho e data de modifica√ß√£o dos arquivos.

# <span style="color: #87BBA2">EXPLORANDO O LINUX SERVER</span>

## NAVEGANDO NO LINUX SERVER
O que significa o `$` em um ambiente Linux?
- Significa que n√£o somos um usu√°rio privilegiado, ou seja, que n√£o conseguimos executar tarefas como administradores desse sistema

-----------------------------------------------------------------------------------

### **Escalando privil√©gios com `sudo`**
Para executar comandos com privil√©gios de administrador (**root**), utilizamos a ferramenta `sudo` (**Super User DO**).  
- Qualquer a√ß√£o com `sudo` pode solicitar a senha do usu√°rio para confirmar a execu√ß√£o.  
- O uso de `sudo` pode ser configurado para permitir ou restringir o acesso a usu√°rios espec√≠ficos. Isso √© feito editando o arquivo `/etc/sudoers` ou adicionando usu√°rios ao grupo `sudo`.  

### **Verificando pacotes e atualiza√ß√µes**
Para atualizar a lista de pacotes dispon√≠veis no sistema, utilizamos:  
```bash
sudo apt update
```
- `apt` (**Advanced Package Tool**) ‚Üí Gerenciador de pacotes do Debian/Ubuntu, usado para instalar, atualizar e remover softwares.  
- `update` ‚Üí Atualiza a lista de pacotes dispon√≠veis nos reposit√≥rios, mas **n√£o instala nada**.  

Depois de atualizar a lista, se quisermos realmente atualizar os pacotes para suas vers√µes mais recentes, usamos:  
```bash
sudo apt upgrade
```
- `upgrade` ‚Üí Instala as vers√µes mais recentes dos pacotes j√° instalados.  

---

### **üìå Significado de algumas siglas importantes**
Aqui est√£o algumas siglas de comandos comuns no Linux:  

- **`sudo`** ‚Üí **Super User DO** (executa comandos como administrador).  
- **`apt`** ‚Üí **Advanced Package Tool** (gerenciador de pacotes do Debian/Ubuntu).    
- **`ls`** ‚Üí **List** (lista arquivos e diret√≥rios).  
- **`cd`** ‚Üí **Change Directory** (muda de diret√≥rio).  
- **`pwd`** ‚Üí **Print Working Directory** (exibe o diret√≥rio atual).  
- **`rm`** ‚Üí **Remove** (remove arquivos/diret√≥rios).  
- **`mv`** ‚Üí **Move** (move ou renomeia arquivos).  
- **`cp`** ‚Üí **Copy** (copia arquivos).  
- **`chmod`** ‚Üí **Change Mode** (muda permiss√µes de arquivos).
  - Usar o comando chmod com a op√ß√£o +x concede permiss√£o de execu√ß√£o a um script em Bash. Por exemplo, voc√™ pode executar o comando chmod +x meu_script.sh para tornar o script "meu_script.sh" execut√°vel no Ubuntu.
- **`chown`** ‚Üí **Change Owner** (muda o dono de um arquivo).  

Para mais retirar mais duvidas sobre os comandos disponiveis, podemos rodar o comando `help`.

### **üìå O que √© Shell CLI?**  
O **Shell** √© um interpretador de comandos que permite interagir com o sistema operacional digitando instru√ß√µes. Ele funciona como uma ponte entre o usu√°rio e o kernel (o n√∫cleo do sistema).  

Ou seja, **Shell** √© um programa que atua como uma **camada de comunica√ß√£o** entre o usu√°rio e o **kernel** (o n√∫cleo do sistema operacional). Ele interpreta os comandos digitados pelo usu√°rio e os repassa para o sistema operacional executar.  

Ele permite:  
‚úÖ Executar programas e comandos  
‚úÖ Gerenciar arquivos e diret√≥rios  
‚úÖ Automatizar tarefas com scripts  
‚úÖ Configurar o sistema  

A **CLI (Command Line Interface)** √© a interface baseada em texto onde esses comandos s√£o inseridos. Diferente de uma interface gr√°fica (GUI), onde usamos cliques e janelas, na CLI **interagimos diretamente com o sistema via comandos**.  

### **üìå Por que o nome "Shell"?**  
O nome **Shell** (que significa "casca" em ingl√™s) foi escolhido porque ele funciona como uma **camada externa** que envolve e protege o kernel do sistema operacional.  

- O **Kernel** √© a parte mais interna e essencial do sistema operacional, respons√°vel por gerenciar hardware e processos.  
- O **Shell** atua como uma "casca protetora" que permite ao usu√°rio interagir com o sistema sem acessar diretamente o kernel.  

üîπ **Analogia:** Imagine um computador como uma **noz**:  
- O **kernel** √© o miolo interno (o n√∫cleo do sistema).  
- O **shell** √© a casca protetora que permite acessar o conte√∫do sem danific√°-lo.  


### **üìå Tipos de Shell**  
No Linux, existem diferentes tipos de Shell, sendo os mais populares:  
- **Bash (Bourne Again Shell)** ‚Üí O mais usado no Linux e Ubuntu.  
- **Zsh (Z Shell)** ‚Üí Uma vers√£o mais avan√ßada do Bash, com mais recursos.  
- **Fish (Friendly Interactive Shell)** ‚Üí Focado em interatividade e facilidade de uso.  

Como voc√™ est√° usando o Ubuntu no VirtualBox, o padr√£o √© o **Bash**. Voc√™ pode verificar qual Shell est√° usando com:  
```bash
echo $SHELL
```

### **üìå Shell no contexto do VirtualBox e Ubuntu**  
No **VirtualBox**, ao instalar o Ubuntu, voc√™ pode interagir com o sistema de duas formas:  
1. **Interface Gr√°fica (GUI)** ‚Üí Se estiver usando o Ubuntu Desktop, ver√° uma tela com bot√µes, menus e janelas.  
2. **Shell CLI** ‚Üí Se estiver no Ubuntu Server (ou acessando o terminal no Desktop), estar√° interagindo apenas por linha de comando.  

No seu caso, como voc√™ est√° configurando a VM, √© prov√°vel que esteja lidando com o **Shell CLI** para instalar pacotes, configurar a rede ou gerenciar arquivos.  

-----------------------------------------------------------------------------------

###  **üìå Estrutura Geral de um Comando no Linux**  
A maioria dos comandos no Linux segue esta estrutura:  

```bash
comando [op√ß√µes] [argumentos]
```

üîπ **Comando** ‚Üí A a√ß√£o a ser executada  
üîπ **Op√ß√µes (flags ou par√¢metros)** ‚Üí Modificam o comportamento do comando  
üîπ **Argumentos** ‚Üí O alvo do comando (arquivo, diret√≥rio, pacote, etc.)  


### **üìå Exemplo 1: Comando `ls`**
```bash
ls -l /home
```
- `ls` ‚Üí **Comando** que lista arquivos e diret√≥rios  
- `-l` ‚Üí **Op√ß√£o (flag)** para exibir detalhes em formato de lista  
- `/home` ‚Üí **Argumento**, especifica o diret√≥rio a ser listado  


### **üìå Exemplo 2: Comando `sudo apt install`**
```bash
sudo apt install vim -y
```
Agora, vamos entender cada parte:  

| Componente  | Defini√ß√£o |
|-------------|----------|
| `sudo`  | **Comando/ferramenta** para executar a√ß√µes como administrador (superusu√°rio). |
| `apt`  | **Comando/ferramenta** para gerenciar pacotes no Ubuntu/Debian. |
| `install` | **Subcomando** do `apt` que indica a a√ß√£o de instala√ß√£o. |
| `vim`  | **Argumento**, ou seja, o pacote que queremos instalar. |
| `-y` | **Op√ß√£o (flag)** que responde "sim" automaticamente √†s perguntas do instalador. |

üîπ **Observa√ß√£o:**  
- `sudo` n√£o √© uma "op√ß√£o", mas sim um **comando separado** que est√° sendo usado antes do `apt`.  
- `install` √© um **subcomando** do `apt`. Muitos comandos possuem subcomandos (ex: `git commit`, `docker run`).  


### **üìå Tipos de Elementos em um Comando**
| Nome         | Defini√ß√£o |
|-------------|----------|
| **Comando**  | A ferramenta ou programa executado (ex: `ls`, `apt`, `cat`, `rm`). |
| **Subcomando** | Algumas ferramentas, como `git` e `apt`, possuem subcomandos (ex: `apt install`, `git commit`). |
| **Op√ß√£o (flag ou par√¢metro)** | Modifica o comportamento do comando (ex: `-l` no `ls -l`). |
| **Argumento** | O alvo do comando (ex: um arquivo, diret√≥rio, pacote). |


### **üìå Teste na Pr√°tica**
Quer saber mais sobre um comando? Use a op√ß√£o `--help`:  

```bash
ls --help
apt --help
```

Ou consulte o manual completo com `man`:  
```bash
man ls
man apt
```

-----------------------------------------------------------------------------------

### Criando um diret√≥rio (pasta) e indo at√© ele
- `mkdir <nome_do_arquivo>`: **Make directory** - cria pasta no diret√≥rio atual
- `cd caminho`: **change directory** - Muda de diret√≥rio. Nesse caso, podemos passar o caminho completo ou o relacional (tipo, passar s√≥ o nome do diret√≥rio caso este esteja imediatamente acessivel no diret√≥rio ao qual atualmente estamos)
- `cd ..` = Este comando n√≥s retornamos uma pasta de n√≠vel superior
- `cd` = Change Directory sem nada, n√≥s voltamos para o ponto inicial. Neste caso, √© a pasta home do usu√°rio.
- `history` = Lista um hist√≥rico de todos os comandos utilizados no ambiente

## GERENCIANDO ARQUIVOS
Apesar de n√£o parecer t√£o intuitivo utilizar o terminal, frente ao que geralmente estamos acostumados (com a interface gr√°fica), no entanto, quando colocamos sistemas em produ√ß√£o e utilizamos servidores, √© esse tipo de ambiente que encontraremos.

Al√©m disso, ambientes como este carrega certa praticidade, uma vez que os comandos passam a ser intuitivos e estes funcionar√£o em qualquer outro servidor, as mesmas ferramentas indepente do servidor e onde ele esteja.

### Criando arquivo (touch)
**Criando um arquivo:**
```bash
touch notas.txt
```
Note que criamos os arquivo mas h√° nada dentro dele.

### Inserindo notas e conferindo (cat)
**Adicionar notas dentro deste arquivo:**
```bash
cat > notas.txt
# Agora, a barra ficar√° piscante aguardando o texto que desejamos incluir
# CTRL + D para sair
```

**Verificando conte√∫do do arquivo:**
```bash
cat notas.txt
# Printado no terminal o conteudo do arquivo
```

### Alternativas de inser√ß√£o de conte√∫do com echo
O comando **echo** tamb√©m consegue inserir conte√∫do em um arquivo
```bash
touch notas_com_echo.txt # criando arquivo
echo Isso √© um teste > notas_com_echo.txt # resultado ser√° parecido, mas n√£o sei como funcionaria com multiline
```

Ao utilizar `echo` sem indicar um arquivo, a a√ß√£o ser√° um print no terminal
- Isso ser√° muito util para escrevermos c√≥digo no futuro
```bash
echo "Hello World"
```

### Outra alternativa comum para edi√ß√£o de texto (nano)
Nano √© um editor de texto comum para ambientes Linux. Caso rodarmos o comando `nano` e termos o retorno `-bash: nano: command not found` √© por que n√£o temos instalado essa ferramenta. Necessitando instala-la.

Podemos instalar o nano com o seguinte comando
```bash
sudo apt-get install nano
```

Agora, damos o comando `nano` e a interface do editor ser√° aberta.
- Escrevemos algumas notas
- `CTRL + X` para sair
- Quando ele pede para **save modified buffer?**, n√≥s damos Y e indicamos onde
- Escrevemos o nome de um arquivo que desejamos salvar este conte√∫do, pode ser um novo arquivo

### Movendo arquivos (mv)
Agora, queremos mover estes arquivos para a pasta devops, mas, fazer um por um n√£o seria adequado. Para isso, a op√ß√£o que o professor utilizou √© compactar os arquivos.

```bash
tar -czf compactado.tar.gz arquivo_2.txt notas.txt
```
Explica√ß√£o do comando:
- **tar:** Comando tar √© o de compacta√ß√£o
- **-czf:** c (cria um arquivo compactado, c para Compact) | z (ser√° um arquivo zip, z para Zip) | f (trata-se de um arquivo, f para File)
- **compactado.tar.gz:** nome_do_arquivo_compactado.extensao (que √© o .tar.gz)
- **arquivo_2.txt notas.txt**: arquivos que quero **compactar**
- **IMPORTANTE:** cria-se um arquivo compactado com os arquivos desejados mas preserva-os, n√£o os deleta

Agora, vamos mover os arquivos desejados
```bash
mv compactado.tar.gz /home/lucasrm/devops
```

### Removendo arquivos (rm)
Para deletar um arquivo, √© s√≥ rodar `rm` e o nome do arquivo:
```bash
rm notas.txt
```

## REMOVENDO ARQUIVOS E DIRET√ìRIOS
No Linux, a remo√ß√£o de arquivos e diret√≥rios pode ser feita de forma simples utilizando comandos no terminal como rm para arquivos e rmdir ou rm -r para diret√≥rios. No entanto, √© importante ter cautela ao utilizar op√ß√µes como -f e -r, pois a remo√ß√£o √© definitiva e n√£o h√° uma lixeira para recupera√ß√£o posterior.

Para remover um arquivo, use o comando rm (remove):
```bash
rm nome_do_arquivo
```

Para remover um diret√≥rio vazio, use o comando rmdir:
```bash
rmdir pasta_vazia
```

Remover um diret√≥rio com conte√∫do Para remover um diret√≥rio e todos os seus arquivos e subdiret√≥rios, use o comando rm com a op√ß√£o -r (recursivo):
```bash
rm -r nome_do_diretorio
```

## IMPORTANTE DICA
Caso queiramos ver as op√ß√µes de um comando, podemos utilizar a op√ß√£o `--h` ao lado de qualquer comando:
```bash
mkdir --h
```

## PARAMETROS DE LISTAGEM
```bash
ls arc* # Lista arquivos/diret√≥rios iniciados com "arc"
ls arcf? # Lista arquuivos/diret√≥rios que iniciam com "arcf" e possuem qualquer outro caracter ap√≥s arcf, limitado a 1. O "?" indica existencia de algum caracter que voc√™ n√£o conhece. Exemplos encontrados: arcf1, arcf2 ...
ls arcf?? # Mesma situa√ß√£o acima, mas com 2 caracteres. Como arcf12 ...
ls 2 # Lista todos os arquivos/diret√≥rios que possuem 2 em qualquer posi√ß√£o do nome
ls ????? # Lista todos os arquivos/diret√≥rios que possuem exatamente 5 caracteres
```

## Praticando
1. Criar dois diret√≥rios chamados dir1 e dir2 na mesma posi√ß√£o hier√°rquica;
2. Entrar no diret√≥rio dir1 e criar dois arquivos chamados data1 e data2;
3. Copiar somente o conte√∫do de dir1 para dir2;
4. Criar um novo diret√≥rio chamado dir3;
5. Mover o conte√∫do de dir1 para dir3.
```bash
mkdir dir1 dir2 # etapa 1
cd dir1 # etapa 2.1
touch data1 data2 # etapa 2.2
cd ..
cp dir1/* dir2 # etapa 3
ls dir2
mkdir dir3 # etapa 4
mv dir1/* dir3 # etapa 5
```

### Outra atividade
Passo 1
- mkdir Docs
- Utilizamos o comando mkdir para criar um novo diret√≥rio. Aqui, estamos criando o diret√≥rio Docs no diret√≥rio atual.

Passo 2
- O comando nano abre o editor de texto Nano, permitindo a edi√ß√£o do arquivo "notas.txt". Se o arquivo n√£o existir, o Nano o criar√°.
- nano notas.txt

Passo 3
- Usamos o comando touchpara criar um novo arquivo vazio.
- touch novo.txt

Passo 4
- O comando echo exibe a string especificada e o operador > redireciona a sa√≠da para o arquivo "saudacao.txt", criando-o se ainda n√£o existir.
- echo "Ol√°, Mundo!" > saudacao.txt

Passo 5
- O comando cat exibe o conte√∫do de um arquivo no terminal.
- cat saudacao.txt

Neste caso, ser√° exibido o conte√∫do do arquivo "saudacao.txt".

Passo 6
- O operador >> √© usado para adicionar (anexar) texto ao final de um arquivo existente.
- echo "Bem-vindo ao Linux!" >> saudacao.txt

Passo 7
- O comando ls √© utilizado para listar o conte√∫do de um diret√≥rio.
- ls Docs

# <span style="color: #87BBA2">SHELL SCRIPTING</span>

## CONSTRUINDO SCRIPTS NO SHELL
Aqui entra um t√≥pico importante, que seria **automatiza√ß√£o de tarefas**, util para n√£o termos que ficar executando comando por comando em a√ß√µes repetidas.
> A nossa principal ideia com automatiza√ß√£o √© executar de uma forma mais inteligente e √°gil uma s√©rie de comandos que ter√≠amos que fazer manualmente na interface.

Ent√£o, criamos o que chamamos de `script` para fazer isso. E a√≠ j√° demos at√© uma pista do que vamos usar. Vamos usar aqui o que chamamos de Shell Scripting (roteiro de comandos).

E o que √© o `script`? O pr√≥prio nome sugere que √© um roteiro, que vai definir como uma atividade ser√° desempenhada de forma automatizada em nosso servidor. Vamos cri√°-lo usando uma linguagem pr√≥pria de script. No nosso caso vai ser o Bash.

### Caso pr√°tico
Uma empresa que necessita, de forma rotineira, criar backup dos dados.
- N√£o seria ideal termos que entrar no terminal e todo dia executarmos o mesmo comando. Para isso, faremos o Shell Scripting

### Criando Shell Script
Para criarmos os nossos scripts, utilizaremos o editor de texto **Nano**, j√° visto anteriormente.

**Escrevendo Shell Script**
- A primeira linha √© para informar quem ser√° o interpretador do comando
  - Escrevemos: `#! /bin/bash`, para dizer que ser√° interpretado pelo bash.
- Em seguida, criamos uma vari√°vel para armazenar o diret√≥rio de backup desejado:
  - `diretorio_backup="/home/lucasrm/devops"
- Na linha de baixo, criamos vari√°vel para o nome do arquivo
  - `nome_arquivo="backup_$(date +%Y%m%d_%H%M%S).tar.gz"`
  - Ou seja: variavel="nomeFixo_$(instrucao de coleta de data).extensaoFixa"
- Na linha de baixo, executaremos o comando para compila√ß√£o
  - `tar -czf "$nome_arquivo" "diretorio_backup"`
  - **-czf:** c (cria um arquivo compactado) | z (gera um arquivo zip) | f (vou especificar o nome do arquivo)
  - "$nome_arquivo": nome do arquivo a ser criado na compacta√ß√£o
  - "diretorio_backup": arquivos que ser√£o compactados
- No fim, informaremos ao usu√°rios que o processo foi realizado com sucesso
  - Utilizaremos o `echo`
  - `echo "Backup concluido em $nome_arquivo"`
- Agora damos um `ctrl X` para sair da interface
- Damos um `Y` para salvar
- Acrescentamos o nome para o shell script
  - Colocamos o nome como "backup.sh" e ele foi salvo no "working directory".

**Executando Shell Script**
- Primeiro, alteramos o shell script para um execut√°vel
  - `chmod +x backup.sh`
- Depois, executamos
  - `bash backup.sh`

**Retornos da execu√ß√£o**
tar: Removing leading `/' from member names
Backup concluido em backup_20231122_175022.tar.gz

Sobre o $():
- Instrumento para informar que dentro dos parenteses ser√° executado um comando
- Comando utilizado: `$(date +%Y%m%d_%H%M%S)`
  - Aqui estamos passando o comando date com a adi√ß√£o (+) de:
    - %Y: Year
    - %d: day
    - %m: month
    - _: separador entre a data e a hora
    - %H: Hour
    - %M: Minutes
    - %S: Seconds

## PARA SABER MAIS: TESTANDO DIFERENTES CONDI√á√ïES
De maneira bastante similar ao que aprendemos em l√≥gica de programa√ß√£o, quando implementamos um script no shell tamb√©m podemos testar uma condi√ß√£o para direcionar a execu√ß√£o de diferentes blocos de instru√ß√µes.

Usamos o comando condicional ifpara avaliar uma condi√ß√£o e direcionar o pr√≥ximo passo na execu√ß√£o do c√≥digo. O trecho de c√≥digo a seguir apresenta a sintaxe adotada no Bash para execu√ß√£o do comando.

```bash
if [ condi√ß√£o ]; then
  # Comandos a serem executados se a condi√ß√£o testada for verdadeira.
elif [ outra condi√ß√£o ]; then
  # Comandos a serem executados se a primeira condi√ß√£o testada for falsa e a segunda condi√ß√£o testada for verdadeira.
else
  # Comandos a serem executados se nenhuma das condi√ß√µes testadas for verdadeira.
fi
```

Repare que a sintaxe do comando possibilita o teste de v√°rias condi√ß√µes, permitindo a execu√ß√£o de diferentes blocos de comandos com base nesses testes.

Na cria√ß√£o dos testes adotamos operadores relacionais e l√≥gicos de diferentes maneiras, como vemos nos exemplos a seguir:

### Igualdade entre duas strings

```bash
if [ "$string1" = "$string2" ]; then
  # Comandos a serem executados se as strings forem iguais.
fi
```

### Desigualdade entre duas strings
```bash
if [ "$string1" != "$string2" ]; then
  # Comandos a serem executados se as strings forem distintas.
fi
```

### Igualdade entre dois n√∫meros
```bash
if [ "$numero1" -eq "$numero2" ]; then
  # Comandos a serem executados se os n√∫meros forem iguais.
fi
```

### Desigualdade entre dois n√∫meros
```bash
if [ "$numero1" -ne "$numero2" ]; then
  # Comandos a serem executados se os n√∫meros forem distintos.
fi
```

### Testando se um n√∫mero √© maior que outro
```bash
if [ "$numero1" -gt "$numero2" ]; then
  # Comandos a serem executados se o primeiro n√∫mero for maior que o segundo.
fi
```

### Testando se um n√∫mero √© menor que outro
```bash
if [ "$numero1" -lt "$numero2" ]; then
  # Comandos a serem executados se o primeiro n√∫mero for menor que o segundo.
fi
```

### Testando se um n√∫mero √© maior ou igual a outro
```bash
if [ "$numero1" -ge "$numero2" ]; then
  # Comandos a serem executados se o primeiro n√∫mero for maior ou igual ao segundo.
fi
```

### Verificando a exist√™ncia de um arquivo ou diret√≥rio
```bash
if [  -e "/caminho/do/arquivo" ]; then
  # Comandos a serem executados caso seja constatada a exist√™ncia do diret√≥rio ou arquivo.
fi
```

Note que as express√µes condicionais devem estar entre [ ] e os espa√ßos em branco s√£o importantes na sintaxe. Os valores de strings devem ser colocados entre aspas para evitar problemas com espa√ßos e caracteres especiais.

## PASSAGEM DE PARAMETROS
Vimos o comando `tar` e sua aplica√ß√£o (cmpacta√ß√£o), o qual √© muito util para:
- Movimentar arquivos entre diret√≥rios e servidores
- Mudar de infraestrutura ou plataforma
- Fazer backups 

E a fun√ß√£o primordial do scripting √© na realiza√ß√£o de automa√ß√µes, n√£o necessitando mais precisar ficar escrevendo comando por comando no terminal.

No script que escrevemos, n√≥s indicamos dentro dele o diret√≥rio que desejamos fazer backup. Como poderiamos deixar esse script mais abstraido para ele funcionar com mais diret√≥rios, solicitando para o usu√°rio indicar o diret√≥rio desejado para backup e o script realizar a fun√ß√£o?

### Scripts com parametros
Primeira coisa, sempre informar o interpretador do script (que no caso, √© o `#! /bin/bash`)

O que desejamos que o usu√°rio fa√ßa:
- Informe o nome do arquivo final
- Informe os arquivos que ser√£o compactados
- Ent√£o, teremos, pelo menos, 2 parametros

#### Validando se parametros foram passados
```bash
if [ "$#" -lt 2 ]; then # Se os parametros passados forem menores do que 2 (-lt: less then), ent√£o (then)
        echo "O programa $0 requer nome do arquivo e arquivos a serem compactados".
        exit 1 # Sai do programa
fi # Encerra bloco if. fi = if ao contr√°rio
```

#### Pegando os parametros
```bash
arquivo_saida="$1" # Pegue o primeiro parametro informado
arquivos=("${@:2}") 
# () = Declarando uma array
# "${@:2}" = O @ significa (pegue todos os parametros). O ":" √© para iniciar um indicador de posi√ß√£o, ou seja, "@:2" significa "Pegue todos os parametros depois do primeiro", j√° que o primeiro parametro ser√° usado para o nome do arquivo de saida
# Com isso, "arquivos" ser√£o todos os demais parametros informados ap√≥s o primeiro.
# A sintaxe √© dentro de aspas e chaves, ainda n√£o sei direito o motivo. Das aspas, imagino que √© porque sempre precisaremos utilizar quando √© algo que n√£o seja reservado ao sistema, pelo que entendi.
```

#### Compactando
```bash
tar -czf "$arquivo_saida" "${arquivos[@]}"
# ${arquivos[@]} representa todos os elementos do array arquivos.
```

üõ† Diferen√ßa entre ${arquivos[@]} e ${arquivos[*]}

üìå ${arquivos[@]}
- Expande cada elemento do array separadamente.
- √â a utiliza√ß√£o do `{}` que realiza a expans√£o da vari√°vel
- Se tivermos arquivos com espa√ßo no nome ("meu arquivo.txt"), ele ser√° tratado corretamente.

üìå ${arquivos[*]}
- Expande todos os elementos como uma √∫nica string, separada por espa√ßos.
- Pode causar problemas com arquivos que cont√™m espa√ßos no nome.
‚úÖ Por isso, a melhor pr√°tica √© usar ${arquivos[@]} para evitar problemas com nomes de arquivos que contenham espa√ßos.

#### Script completo
```bash
#! /bin/bash

if [ "$#" -lt 2 ]; then
        echo "O programa $0 requer nome do arquivo e arquivos a serem compactados".
        exit 1
fi
arquivo_saida="$1"
arquivos=("${@:2}")
tar -czf "$arquivo_saida" "${arquivos[@]}"
echo "Compactado com sucesso em $arquivo_saida"
```

#### Executando script
```bash
chmod +x compactador # Mudando permiss√£o de execu√ß√£o
./compactador # Executa o c√≥digo

# Retorno: rquer nome do arquivo e arquivos a serem compactados
```

```bash
./compactador saida.tar.gz /home/lucasrm/texto2.txt /home/lucasrm/texto3.txt
# retorno: mensagens de compacta√ß√£o e mensagem de sucesso

tar -tf saida.tar.gz # Comando para descompacta√ß√£o para conferir se deu tudo certo
```

## PARA SABER MAIS: PASSANDO PARAMETROS EM SCRIPTS
A passagem de par√¢metros em scripts em Bash no Ubuntu √© uma forma de fornecer informa√ß√µes ou argumentos para o script durante sua execu√ß√£o. Isso torna os scripts mais flex√≠veis e reutiliz√°veis, pois seu comportamento √© ajustado de acordo com os argumentos fornecidos.

Essa passagem de par√¢metros √© realizada por meio de vari√°veis especiais, conhecidas como vari√°veis de posi√ß√£o. Elas s√£o numeradas de 1 a 9, com $1 representando o primeiro argumento, $2 representando o segundo, e assim por diante. Al√©m disso, todos os argumentos posicionais podem ser acessados atrav√©s do $@.

A seguir, temos um exemplo de script que verifica se foram fornecidos exatamente dois argumentos na linha de comando. Se n√£o, ele exibe uma mensagem de erro. Caso contr√°rio, ele atribui os valores dos argumentos √†s vari√°veis arg1 e arg2 e os imprime.

```bash
#!/bin/bash

if [ $# -ne 2 ]; then
  echo "Erro! Nao foram fornecidos dois argumentos"
  exit 1
fi

arg1=$1
arg2=$2

echo "O primeiro argumento √©: $arg1"
echo "O segundo argumento √©: $arg2"
```

√ìtima pergunta, Ronan! Vamos esclarecer essa diferen√ßa de uma vez por todas. üí°üöÄ  

---

## **üìå Diferen√ßa entre `$VARIAVEL` e `${VARIAVEL}`**

Ambas as formas s√£o usadas para referenciar o valor de uma vari√°vel no Bash, **mas `${}` √© mais seguro e flex√≠vel**.

| Forma  | Explica√ß√£o |
|--------|------------|
| `$VARIAVEL` | Forma simples. Funciona na maioria dos casos. |
| `${VARIAVEL}` | Forma mais segura. √ötil quando precisamos concatenar ou evitar ambiguidades. |

---

### **üéØ Exemplo pr√°tico: Quando `${}` √© necess√°rio**
Vamos supor que temos esta vari√°vel:
```bash
nome="Ronan"
```

Agora, tentamos imprimir **"RonanDev"** concatenando `"Dev"` no final:

```bash
echo "$nomeDev"    # ERRO! Bash procura por uma vari√°vel chamada "nomeDev"
echo "${nome}Dev"  # CORRETO! Expande "Ronan" e concatena "Dev"
```
üìå **Explica√ß√£o**:
- `$nomeDev` ‚Üí O Bash **procura uma vari√°vel chamada `nomeDev`**, que n√£o existe.  
- `${nome}Dev` ‚Üí O Bash **expande `nome` corretamente** e depois adiciona `"Dev"`.

---

### **üìå Seguran√ßa e legibilidade**
Outra vantagem de `${}` √© evitar ambiguidades. Exemplo:
```bash
ARQUIVO="backup"
echo "O arquivo √© $ARQUIVO2024"  # ERRO! Procura vari√°vel $ARQUIVO2024 (que n√£o existe)
echo "O arquivo √© ${ARQUIVO}2024"  # CORRETO! Retorna "O arquivo √© backup2024"
```

üìå **Conclus√£o**: Sempre que for concatenar algo ou evitar ambiguidades, **use `${}`**.  

---

### **üî• Resumo final**
| Uso  | Quando usar? |
|------|-------------|
| `$VARIAVEL`  | Para refer√™ncias simples. |
| `${VARIAVEL}`  | Para evitar ambiguidades, concatenar valores ou melhorar legibilidade. |

Agora voc√™ manja como um verdadeiro mestre do Bash! üöÄüî•

## EXEMPLOS DE SCRIPT

### Verificando existencia de arquivos na pasta
```bash
arquivos=("$@") # Pega todos os parametros
for arquivo in "${arquivos[@]}"; do # Loop for
  if [ ! -e "$arquivo" ]; then # Se n√£o tiver arquivo
    echo "Arquivo n√£o encontrado: $arquivo"
    exit 1 # Sai do script
  fi
done # Indicador de finaliza√ß√£o do bloco For
```

### Verifique a validade do caminho informado
```bash
#!/bin/bash

# Solicitamos ao usu√°rio o caminho do diret√≥rio
read -p "Digite o caminho do diret√≥rio: " caminho

# Verificamos se o caminho do diret√≥rio √© v√°lido
if [ -d "$caminho" ]; then
    echo "O caminho √© um diret√≥rio v√°lido."
else
    echo "O caminho n√£o √© um diret√≥rio v√°lido ou ele n√£o existe."
fi
```
-  operador `-d` verifica se o caminho fornecido $caminho √© um diret√≥rio v√°lido

### Exiba uma mensagem de boas-vindas quando executado
```bash
#!/bin/bash
echo "Bem-vindo ao meu script!"
```

### Criar uma c√≥pia de seguran√ßa de um diret√≥rio espec√≠fico
```bash
#!/bin/bash
tar -czf backup.tar.gz /caminho/do/diretorio
```

### Solicite ao usu√°rio o nome de um diret√≥rio e, em seguida, o crie
```bash
#!/bin/bash
echo "Digite o nome do diret√≥rio:"
read nome_diretorio
mkdir $nome_diretorio
```

### Aceite um nome de arquivo como argumento e verifique se o arquivo existe
```bash
#!/bin/bash
echo "Digite o nome do arquivo:"
read nome_arquivo
if [ -e $nome_arquivo ]; then
  echo "O arquivo existe."
else
  echo "O arquivo n√£o existe."
fi
```

### Utilize um loop para contar de 1 a 5
```bash
#!/bin/bash
for i in {1..5}
do
  echo $i
done
```

# <span style="color: #87BBA2">AUTOMATIZA√á√ÉO DE TAREFAS</span>

## EXECUTANDO MULTIPLAS TAREFAS
```bash
#! /bin/bash
read -p "Entre com a operacao desejada: 'compactar' ou 'descompactar'" operacao
case "$operacao" in
        "compactar")
                read -p "Nome do arquivo final (.tar.gz)" arquivo_saida
                read -p "Lista de arquivos separados por espa√ßo:" arquivos
                tar -czf "$arquivo_saida" $arquivos
                echo "Compactados com sucesso em $arquivo_saida"
        ;;
        "descompactar")
                read -p "Qual √© o nome do arquivo a ser a descompactar (.tar.gz)" arquivo
                read -p "Diretorio de destino" diretorio
                tar -xzf "$arquivo" -C "$diretorio"
                echo "Descompactado com sucesso em $diretorio"
        ;;
        *)
        echo "Operacao invalida!"
        echo "Selecione descompactar ou compactar"
        exit 1
        ;;
esac
```

### Notas
- `read -p`: Armazena a op√ß√£o digitada pelo usu√°rio em uma vari√°vel
  - Sua sintaxe: `read -p <mensagem_que_aparecer√°_para_o_usu√°rio> <nome_da_variavel>`
  - Exemplo: `read -p "O que voc√™ digitar, ir√° para a vari√°vel ao lado" variavel_ao_lado`

#### Sintaxe case
```bash
# SINTAXE
case "<variavel_a_ser_lida>" in
        "<valor_esperado_1>")
                # bloco de execu√ß√£o
        ;; # indicador de fim do bloco
        "<valor_esperado_2>")
                # bloco de execu√ß√£o
        ;; # Indicador de fim do bloco
        # demais valores + blocos que quiser
        # A op√ß√£o abaixo √© para valores default, ou seja, tudo que n√£o seja as op√ß√µes acima
        *)
                # Valores Default
                # bloco de execu√ß√£o
        ;; # indicador de fim do bloco
esac # Indicador de fim do bloco case

# EXEMPLO
case "$operacao" in
        "compactar")
                read -p "Nome do arquivo final (.tar.gz)" arquivo_saida
                read -p "Lista de arquivos separados por espa√ßo:" arquivos
                tar -czf "$arquivo_saida" $arquivos
                echo "Compactados com sucesso em $arquivo_saida"
        ;;
        "descompactar")
                read -p "Qual √© o nome do arquivo a ser a descompactar (.tar.gz)" arquivo
                read -p "Diretorio de destino" diretorio
                tar -xzf "$arquivo" -C "$diretorio"
                echo "Descompactado com sucesso em $diretorio"
        ;;
        *)
                echo "Operacao invalida!"
                echo "Selecione descompactar ou compactar"
                exit 1
        ;;
esac
```

#### Descompactando
Comando: `tar -xzf "$arquivo" -C "$diretorio"`
- **-xzf:** x (extraia um arquivo compactado, x para Xtract) | z (o arquivo √© zip, z para Zip) | f (trata-se de um arquivo, f para File)

## SHELL SCRIPTING COM APENAS OS DOCUMENTOS

### Compactando apenas arquivos
```bash
#! /bin/bash
read -p "Entre com a operacao desejada: 'compactar' ou 'descompactar'" operacao
case "$operacao" in
	"compactar")
		read -p "Nome do arquivo final (.tar.gz): " arquivo_saida
		read -p "Caminho dos arquivos a compactar: " caminho
		read -p "Lista de arquivos separados por espa√ßo: " arquivos

		tar -czf "$arquivo_saida" -C "$caminho" $arquivos

		echo "Compactados com sucesso em $arquivo_saida"
	;;
	"descompactar")
		read -p "Qual √© o nome do arquivo a ser a descompactar (.tar.gz)" arquivo
		read -p "Diretorio de destino" diretorio

		tar -xzf "$arquivo" -C "$diretorio"

		echo "Descompactado com sucesso em $diretorio"
	;;
	*)
		echo "Operacao invalida!"
		echo "Selecione descompactar ou compactar"
		exit 1
	;;
esac
```
- Pedimos caminho base ao usu√°rio
- Flag `-c "$caminho"` entra no diret√≥rio antes da compacta√ß√£o
- O resultado ser√° um `.tar.gz` sem os caminhos completos, apenas com os arquivos desejados.

### Compactando caminho, descompactando apenas os arquivos
```bash
#! /bin/bash
read -p "Entre com a operacao desejada: 'compactar' ou 'descompactar'" operacao
case "$operacao" in
	"compactar")
		read -p "Nome do arquivo final (.tar.gz)" arquivo_saida
		read -p "Lista de arquivos separados por espa√ßo:" arquivos
    
		tar -czf "$arquivo_saida" $arquivos
    
		echo "Compactados com sucesso em $arquivo_saida"
	;;
	"descompactar")
		read -p "Qual √© o nome do arquivo a ser a descompactar (.tar.gz)" arquivo
		read -p "Diretorio de destino" diretorio

		tar --strip-components=1 -xzf "$arquivo" -C "$diretorio"

		echo "Descompactado com sucesso em $diretorio"
	;;
	*)
		echo "Operacao invalida!"
		echo "Selecione descompactar ou compactar"
		exit 1
	;;
esac
```
- Isso faz com que o primeiro n√≠vel de diret√≥rios seja ignorado na extra√ß√£o.

## FUN√á√ïES DIRETAS NO CLI  
N√£o √© obrigat√≥rio escrever um script separado. Voc√™ pode declarar e chamar fun√ß√µes diretamente no terminal.  

### **üî• Criando uma fun√ß√£o direto no CLI**
```bash
minha_funcao() {
  echo "Ol√°, Ronan! Essa fun√ß√£o foi criada no terminal. üöÄ"
}
```
Agora, basta cham√°-la:
```bash
minha_funcao
```
Sa√≠da:
```
Ol√°, Ronan! Essa fun√ß√£o foi criada no terminal. üöÄ
```

---

### **üìå Passando par√¢metros para a fun√ß√£o**
```bash
saudacao() {
  echo "Ol√°, $1! Seja bem-vindo ao mundo do Bash. üî•"
}
```
Chamando com um argumento:
```bash
saudacao Ronan
```
Sa√≠da:
```
Ol√°, Ronan! Seja bem-vindo ao mundo do Bash. üî•
```

---

### **üìå Fun√ß√µes mais complexas**
Quer renomear todos os arquivos da pasta `arquivos/`, adicionando `.txt`? Faz assim:  
```bash
renomear_arquivos() {
  for file in arquivos/*; do
    [[ "$file" == *.txt ]] || mv "$file" "${file}.txt"
  done
  echo "Arquivos renomeados com sucesso! ‚úÖ"
}
```
Depois, chama direto no CLI:
```bash
renomear_arquivos
```

---

### **üìå Mas e se eu fechar o terminal?**
Se voc√™ definir a fun√ß√£o no CLI, ela **some ao fechar o terminal**.  

üí° **Solu√ß√£o:** Para salvar a fun√ß√£o permanentemente, adicione ao `~/.bashrc` ou `~/.bash_profile`:
```bash
echo 'saudacao() { echo "Ol√°, $1! Seja bem-vindo ao Bash. üî•"; }' >> ~/.bashrc
source ~/.bashrc
```

---

### **üöÄ Resumo**
‚úî **Sim, voc√™ pode criar fun√ß√µes direto no terminal.**  
‚úî Para persist√™ncia, adicione no `~/.bashrc` ou `~/.bash_profile`.  
‚úî Pode chamar fun√ß√µes no CLI como qualquer comando normal.  

Agora voc√™ t√° pronto para automatizar tudo no Bash! üî•üíª

## QUANDO USAR E QUANDO N√ÉO USAR ASPAS
√ìtima pergunta! O uso (ou n√£o) das aspas no shell script pode afetar o comportamento dos comandos. Vamos analisar a diferen√ßa no seu snippet:

```bash
tar -czf "$arquivo_saida" -C "$caminho" $arquivos
```

---

### **1Ô∏è‚É£ Por que `"$arquivo_saida"` e `"$caminho"` t√™m aspas?**
‚úÖ **Protege valores que podem conter espa√ßos**  

Se as vari√°veis **podem conter espa√ßos ou caracteres especiais**, devemos **usar aspas** para garantir que o valor seja tratado como um √∫nico argumento.  

**Exemplo sem aspas:**
```bash
arquivo_saida="meu backup.tar.gz"
tar -czf $arquivo_saida -C /home/user Documents
```
Expande para:
```bash
tar -czf meu backup.tar.gz -C /home/user Documents
```
üö® **ERRO!** O `tar` agora interpreta **"meu"** como o nome do arquivo e **"backup.tar.gz"** como outro argumento.

**Exemplo com aspas (correto):**
```bash
arquivo_saida="meu backup.tar.gz"
tar -czf "$arquivo_saida" -C /home/user Documents
```
Agora, `tar` v√™ `"meu backup.tar.gz"` como um √∫nico argumento. ‚úÖ

**Por isso `"$arquivo_saida"` e `"$caminho"` t√™m aspas**:  
- `"$arquivo_saida"` ‚Üí O nome do arquivo pode conter espa√ßos.  
- `"$caminho"` ‚Üí O caminho pode ter espa√ßos, como `/home/ronan/Meus Documentos/`.

---

### **2Ô∏è‚É£ Por que `$arquivos` est√° sem aspas?**
üö® **Porque queremos que o shell expanda corretamente v√°rios argumentos.**  

Se `arquivos="arquivo1.txt arquivo2.txt arquivo3.txt"`, e usarmos **aspas**, o comportamento muda:

```bash
tar -czf "$arquivo_saida" -C "$caminho" "$arquivos"
```
Isso **passaria tudo como um √∫nico argumento**:
```bash
tar -czf "meu backup.tar.gz" -C "/home/user" "arquivo1.txt arquivo2.txt arquivo3.txt"
```
‚ùå **ERRO:** `tar` tentaria compactar um **√∫nico arquivo** chamado `"arquivo1.txt arquivo2.txt arquivo3.txt"`.

Sem aspas, cada arquivo √© tratado individualmente:
```bash
tar -czf "$arquivo_saida" -C "$caminho" $arquivos
```
Expande para:
```bash
tar -czf "meu backup.tar.gz" -C "/home/user" arquivo1.txt arquivo2.txt arquivo3.txt
```
‚úÖ **CORRETO:** `tar` recebe cada arquivo separadamente.

---

### **üìå Regra Geral**
| Tipo de vari√°vel  | Deve usar aspas? | Exemplo correto |
|------------------|----------------|----------------|
| **Vari√°vel √∫nica (caminho, nome de arquivo, string)** | ‚úÖ Sim  | `"$arquivo_saida"`, `"$caminho"` |
| **Lista de argumentos separados por espa√ßo** (`$@`, `$arquivos`) | üö´ N√£o  | `$arquivos`, `$@` |
| **Lista de argumentos separados por espa√ßo dentro de um array** | ‚úÖ Sim (com `"${array[@]}"`)  | `"${arquivos[@]}"` |

---

### **Resumo**
‚úÖ **Aspas** em **caminhos ou nomes de arquivos** previnem erros com espa√ßos.  
üö´ **Sem aspas** em **listas de argumentos** permite que cada item seja tratado corretamente.  

Se o `$arquivos` fosse um **array**, a√≠ sim usar√≠amos `"${arquivos[@]}"`. 

## INSTALANDO UM SERVIDOR WEB

### O que √© um servidor web
Falamos muito sobre **servidores** at√© o momento, principalmente porque estamos lidando diretamente com um. Mas por que falamos tanto sobre servidor?

Quando acessamos uma p√°gina web, como a p√°gina da Alura, para realizar este ou outros cursos, esta p√°gina n√£o est√° hospedada no seu celular ou no seu computador, mas em um **servidor**.

Normalmente, desejamos ter um acesso r√°pido, √°gil, n√£o queremos esperar alguns segundos para o v√≠deo carregar. Isso afeta muito a nossa experi√™ncia como pessoas usu√°rias de um site ou mesmo de um servi√ßo, como, por exemplo, um servi√ßo de streaming.

Para que isso ocorra de forma √°gil e com qualidade, precisamos de um software rodando no nosso servidor, especificamente para atender a essas solicita√ß√µes encaminhadas pelos nossos dispositivos para ele. **Este software √© chamado de servidor web**.

A finalidade deste servidor √© atender √†s solicita√ß√µes que chamamos de **HTTP**, protocolo de comunica√ß√£o usado para interagir com recursos e acessar p√°ginas web localizadas em servidores.

Mas como preparamos um servidor web? √â poss√≠vel instalarmos um servidor web neste servidor Ubuntu no qual temos trabalhado? Sim, √© poss√≠vel!

Op√ß√µes open-source de servidores web:
- Apache
  - Funciona bem para atendimento a grandes demandas e utiliza√ß√£o de modulos diversos.
- Nginx
  - Costuma sendo muito usados em considera√ß√£o a performance e conteudos est√°ticos.
  - O Nginx √© conhecido por sua alta efici√™ncia e performance quando lidando com conte√∫do est√°tico e alto volume de tr√°fego.

### Insalando Nginx em nosso servidor
Primeiro, iremos realizar uma atualiza√ß√£o dos pacotes de nosso servidor
```bash
sudo apt update # Verifica os pacotes a serem instalados
sudo apt-get update # Instala de fato os pacotes
```
- Ser√° solicitado sua senha, pois √© um comando `sudo`, ou seja, estamos escalando privil√©gios

Agora, iremos instalar o **Nginx**
```bash
sudo apt install nginx
```
1. Responderemos que sim, para confirmar a instala√ß√£o

#### Verificando servidor web
Para verificar se o servidor web est√° de fato rodando em nosso servidor, utilizaremos uma ferramenta que auxilia a monitorar o desempenho de unidades e servi√ßos dentro do servidor:
```bash
sudo systemctl status nginx
```

Mas, e se rodassemos o `systemctl status` sem informar `nginx`?
```bash
sudo systemctl status
```
- Ser√° retornado o status de todas as unidades do nosso servidor ubuntu.
- Ferramenta muito util para monitorarmos, diagnosticarmos erros, monitorar como esta o desempenho das diferentes unidades e servi√ßos de instalados em nosso servidor.

## CONVERS√ÉO DE ARQUIVOS
Imagine que voc√™ tenha v√°rios arquivos na extens√£o .jpg em um diret√≥rio do seu reposit√≥rio local de armazenamento e deseja mudar sua extens√£o para .png. Seria poss√≠vel criar um script que operasse essa convers√£o de forma pr√°tica e automatizada, ou seja, sem a necessidade de converter arquivo por arquivo?

Temos uma ferramenta muito √∫til nesse processo: o comando convert. Esse comando nos permite converter, editar e exibir imagens em diversos formatos.

A sintaxe do comando √© bem pr√°tica:
```bash
convert [op√ß√µes] arquivo_entrada arquivo_sa√≠da
```
Para converter uma imagem de .jpg para .png, podemos escrever a seguinte instru√ß√£o:
```bash
convert imagem.jpg imagem.png
```
E se quis√©ssemos redimensionar um conjunto de imagens .jpg para uma resolu√ß√£o padr√£o 800x600?
```bash
convert imagem.jpg -resize 800x600 imagem_redimensionada.jpg
```

### Script
```bash
# Indicamos o interpretador
#!/bin/bash

# Solicitamos a indica√ß√£o do caminho do diret√≥rio
read -p "Digite o caminho do diret√≥rio com as imagens JPG: " diretorio

# Verificamos se o diret√≥rio indicado existe
if [ ! -d "$diretorio" ]; then
    echo "Diret√≥rio n√£o encontrado: $diretorio"
    exit 1
fi

# Convertemos todas as imagens JPG para PNG no diret√≥rio
for imagem_jpg in "$diretorio"/*.jpg; do
    convert "$imagem_jpg" "${imagem_jpg%.jpg}.png" && echo "Imagem convertida: ${imagem_jpg%.jpg}.png" || echo "Falha na convers√£o: $imagem_jpg"
done

echo "Convers√£o conclu√≠da!"
```

O trecho `${imagem_jpg%.jpg}` √© um exemplo de **substitui√ß√£o de padr√µes (parameter expansion)** no Bash. Ele **remove a menor correspond√™ncia** do sufixo especificado (.jpg) da vari√°vel imagem_jpg.

Exemplo:
```bash
arquivo="foto.jpg.backup.jpg"
echo "${arquivo%.jpg}.png"

# retorno: foto.jpg.backup.png
```

Mas se quisermos **remover todas as ocorr√™ncias** de .jpg, usamos %% (duplo %):
```bash
arquivo="foto.jpg.backup.jpg"
echo "${arquivo%%.jpg}.png"

# retorno: foto.png
```

## EXEMPLO DE SCRIPTS
### automatiza a atualiza√ß√£o de pacotes do sistema operacional.
```bash
#!/bin/bash
sudo apt update -y
sydo apt upgrade -y
```
O script utiliza os comandos apt update e apt upgrade para automatizar a atualiza√ß√£o de pacotes no sistema operacional Debian/Ubuntu. O par√¢metro -y √© usado para confirmar automaticamente todas as perguntas de confirma√ß√£o.

### renomeie todos os arquivos em um diret√≥rio, adicionando um prefixo ou sufixo especificado
```bash
#!/bin/bash
prefixo="Novo_"
for arquivo in *; do
        mv "$arquivo" "$prefixo$arquivo"
done
```

### automatiza a cria√ß√£o de usu√°rios no sistema, solicitando ao usu√°rio que forne√ßa o nome e outros detalhes necess√°rios
```bash
#!/bin/bash
read -p "Digite o nome do novo usu√°rio: " nome_usuario
sudo useradd -m $nome_usuario
sudo passwd $nome_usuario
```
O script solicita ao usu√°rio o nome do novo usu√°rio, cria um diret√≥rio pessoal para o usu√°rio (useradd -m), e define uma senha (passwd).
- Existe tamb√©m o adduser, que j√° configura bastante coisa automaticamente. useradd √© um comando Debian/Ubuntu de baixo n√≠vel

### monitorar o espa√ßo em disco usando o comando df na coleta de informa√ß√µes
```bash
#!/bin/bash
limite=90
espaco=$(df -h | awk 'NR==2 {print $5}' | sed 's/%//')

if [ $espaco -gt $limite ]; then
      echo "Alerta: Espa√ßo em disco excedeu $limite%."
else
      echo "Espa√ßo em disco est√° abaixo do limite"
fi
```
O script coleta a porcentagem de espa√ßo em disco usando o comando df, compara com um limite predefinido (90% neste exemplo) e emite um alerta se exceder.

Fala, Parceir√£o! Sem problema nenhum, tamo junto! Vou destrinchar o que acontece na vari√°vel `espaco` linha por linha.  

### **üìå O que acontece em `espaco`?**
```bash
espaco=$(df -h | awk 'NR==2 {print $5}' | sed 's/%//')
```
üëâ **Ela pega a porcentagem de uso do disco e remove o s√≠mbolo `%`.**  
Agora, vamos **quebrar** cada parte para entender direitinho:

---

#### **1Ô∏è‚É£ `df -h` ‚Üí Verifica o espa√ßo em disco**
```bash
df -h
```
üîπ `df` (**Disk Free**) ‚Üí Exibe o uso do disco.  
üîπ `-h` (**human-readable**) ‚Üí Mostra os valores de forma leg√≠vel (`G`, `M`, `%`).  

Exemplo de sa√≠da:
```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1      100G   85G   15G  85%  /
tmpfs           16G     0   16G   0%  /dev/shm
```
‚úîÔ∏è O n√∫mero que **importa** para o script √© o da **coluna "Use%"**, que indica quanto do disco est√° ocupado.

---

#### **2Ô∏è‚É£ `awk 'NR==2 {print $5}'` ‚Üí Filtra a linha e coluna certas**
```bash
awk 'NR==2 {print $5}'
```
üîπ **`awk`** √© uma linguagem de manipula√ß√£o de texto.  
üîπ **`NR==2`** ‚Üí Seleciona **a segunda linha** da sa√≠da do `df -h` (onde est√£o os dados do disco principal).  
üîπ **`{print $5}`** ‚Üí Exibe a **quinta coluna**, que √© o valor da porcentagem de uso (`85%` no exemplo).  

---

#### **3Ô∏è‚É£ `sed 's/%//'` ‚Üí Remove o s√≠mbolo `%`**
```bash
sed 's/%//'
```
üîπ `sed` (**stream editor**) edita o texto.  
üîπ `s/%//` ‚Üí Substitui (`s/`) o s√≠mbolo `%` **por nada**, removendo-o.  
‚úîÔ∏è Agora, `espaco` cont√©m apenas o n√∫mero (`85`), facilitando a compara√ß√£o.

---

### **üìå Recapitulando o que acontece**
```bash
espaco=$(df -h | awk 'NR==2 {print $5}' | sed 's/%//')
```
1Ô∏è‚É£ **`df -h`** ‚Üí Mostra o espa√ßo em disco.  
2Ô∏è‚É£ **`awk 'NR==2 {print $5}'`** ‚Üí Pega **a porcentagem de uso** (`85%`).  
3Ô∏è‚É£ **`sed 's/%//'`** ‚Üí Remove `%`, deixando s√≥ o n√∫mero (`85`).  

---

### **üìå Exemplo pr√°tico**
Se rodarmos o comando direto no terminal:
```bash
$ df -h | awk 'NR==2 {print $5}' | sed 's/%//'
85
```
O valor `85` ser√° salvo na vari√°vel `espaco`, permitindo a compara√ß√£o no `if`:
```bash
if [ $espaco -gt $limite ]; then
```

### automatizar o backup de um diret√≥rio espec√≠fico para um local de destino, utilizando a compress√£o gzip
```bash
#!/bin/bash
origem="/caminho/do/diretorio"
destino="/caminho/do/backup"
data=$(date +"%Y%m%d")
tar -czf $destino/backup_$data.tar.gz $origem
```
O script utiliza o comando `tar` para criar um arquivo compactado e tarball, adicionando a data ao nome do arquivo para distinguir backups di√°rios. O gzip (`-z`) √© usado para compress√£o.